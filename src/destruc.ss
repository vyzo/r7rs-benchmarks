;;; DESTRUC -- Destructive operation benchmark.

(def (append-to-tail! x y)
  (if (null? x)
    y
    (using (x :- :pair)
      (let loop (((a :- :pair) x) (b (cdr x)))
        (if (null? b)
          (begin
            (set-cdr! a y)
            x)
          (using (b :- :pair)
            (loop b (cdr b))))))))

(define (destructive n m)
  (let (l (do (((i :- :fixnum) 10 (fx- i 1))
               (a [] (cons [] a)))
              ((fx= i 0) a)))
    (do (((i :- :fixnum) n (fx- i 1)))
        ((fx= i 0) l)
      (cond
       ((null? (car l))
        (do ((l l (cdr l)))
            ((null? l))
          (using (l :- :pair)
            (when (null? (car l))
              (set-car! l (cons [] [])))
            (append-to-tail! (car l)
                             (do (((j :- :fixnum) m (fx- j 1))
                                  (a [] (cons [] a)))
                                 ((fx= j 0) a))))))
       (else
        (do ((l1 l (cdr l1))
             (l2 (cdr l) (cdr l2)))
            ((null? l2))
          (set-cdr!
           (do (((j :- :fixnum) (fxquotient (length (car l2)) 2) (fx- j 1))
                ((a :- :pair) (car l2) (cdr a)))
               ((fx= j 0) a)
             (set-car! a i))
           (using (l1 :- :pair)
             (let ((n (fxquotient (length (car l1)) 2)))
               (cond
                ((fx= n 0)
                 (set-car! l1 [])
                 (car l1))
                (else
                 (do (((j :- :fixnum) n (fx- j 1))
                      ((a :- :pair) (car l1) (cdr a)))
                     ((fx= j 1)
                      (let ((x (cdr a)))
                        (set-cdr! a [])
                        x))
                   (set-car! a i)))))))))))))

(define (run-benchmark)
  (let* ((count (read))
         (input1 (read))
         (input2 (read))
         (output (read))
         (s3 (number->string count))
         (s2 (number->string input2))
         (s1 (number->string input1))
         (name "destruc"))
    (run-r7rs-benchmark
     (string-append name ":" s1 ":" s2 ":" s3)
     count
     (lambda ()
       (destructive (hide count input1) (hide count input2)))
     (lambda (result) (equal? result output)))))

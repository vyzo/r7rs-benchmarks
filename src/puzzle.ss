;;; PUZZLE -- Forest Baskett's Puzzle benchmark, originally written in Pascal.

(def (my-iota (n : :fixnum))
  (do (((n :- :fixnum) n (fx- n 1))
       (list '() (cons (fx- n 1) list)))
      ((fx= n 0) list)))

(def *size* 511)
(def classmax 3)
(def typemax 12)

(def *iii* 0)
(def *kount* 0)
(def *d* 8)

(def *piececount* (make-u16vector (+ classmax 1) 0))
(def *class* (make-u16vector (+ typemax 1) 0))
(def *piecemax* (make-u16vector (+ typemax 1) 0))
(def *puzzle* (make-vector (+ *size* 1) #f))
(def *p* (make-vector (+ typemax 1) #f))

(def (fit (i : :fixnum) (j : :fixnum))
  (let (end (u16vector-ref *piecemax* i))
    (do (((k :- :fixnum) 0 (fx+ k 1)))
        ((or (fx> k end)
             (and (vector-ref (vector-ref *p* i) k)
                  (vector-ref *puzzle* (fx+ j k))))
         (fx> k end)))))

(def (place (i : :fixnum) (j : :fixnum))
  => :fixnum
  (let (end (u16vector-ref *piecemax* i))
    (do (((k :- :fixnum) 0 (fx+ k 1)))
        ((fx> k end))
      (when (vector-ref (vector-ref *p* i) k)
        (vector-set! *puzzle* (fx+ j k) #t)))
    (u16vector-set! *piececount*
                   (u16vector-ref *class* i)
                   (fx- (u16vector-ref *piececount* (u16vector-ref *class* i)) 1))
    (:- (do (((k :- :fixnum) j (fx+ k 1)))
            ((or (fx> k *size*) (not (vector-ref *puzzle* k)))
             (if (fx> k *size*) 0 k)))
        :fixnum)))

(def (puzzle-remove (i : :fixnum) (j : :fixnum))
  (let (end (u16vector-ref *piecemax* i))
    (do (((k :- :fixnum) 0 (fx+ k 1)))
        ((fx> k end))
      (when (vector-ref (vector-ref *p* i) k)
        (vector-set! *puzzle* (fx+ j k) #f)))
    (let (klass (u16vector-ref *class* i))
      (u16vector-set! *piececount*
                      klass
                      (fx+ (u16vector-ref *piececount* klass) 1)))))

(def (trial (j : :fixnum))
  (let ((k 0))
    (call-with-current-continuation
     (lambda ((return :- :procedure))
       (do (((i :- :fixnum) 0 (fx+ i 1)))
           ((fx> i typemax) (set! *kount* (fx+ *kount* 1)) #f)
         (unless (fx= 0 (u16vector-ref *piececount* (u16vector-ref *class* i)))
           (when (fit i j)
             (set! k (place i j))
             (cond
              ((or (trial k) (fx= k 0))
               (set! *kount* (+ *kount* 1))
               (return #t))
              (else (puzzle-remove i j))))))))))

(def (definePiece (iclass : :fixnum) (ii : :fixnum) (jj : :fixnum) (kk : :fixnum))
  (let ((index 0))
    (do (((i :- :fixnum) 0 (fx+ i 1)))
        ((fx> i ii))
      (do (((j :- :fixnum) 0 (fx+ j 1)))
          ((fx> j jj))
        (do (((k :- :fixnum) 0 (fx+ k 1)))
            ((fx> k kk))
          (set! index (fx+ i (fx* *d* (fx+ j (fx* *d* k)))))
          (vector-set! (vector-ref *p* *iii*) index  #t))))
    (u16vector-set! *class* *iii* iclass)
    (u16vector-set! *piecemax* *iii* index)
    (unless (fx= *iii* typemax)
      (set! *iii* (fx+ *iii* 1)))))

(def (start (size : :fixnum))
  (set! *kount* 0)
  (do (((m : :fixnum) 0 (fx+ m 1)))
      ((fx> m size))
    (vector-set! *puzzle* m #t))
  (do (((i :- :fixnum) 1 (+ i 1)))
      ((fx> i 5))
    (do (((j :- :fixnum) 1 (fx+ j 1)))
        ((fx> j 5))
      (do (((k :- :fixnum) 1 (fx+ k 1)))
          ((fx> k 5))
        (vector-set! *puzzle* (fx+ i (fx* *d* (fx+ j (fx* *d* k)))) #f))))
  (do (((i :- :fixnum) 0 (fx+ i 1)))
      ((fx> i typemax))
    (do (((m :- :fixnum) 0 (fx+ m 1)))
        ((fx> m size))
      (vector-set! (vector-ref *p* i) m #f)))
  (set! *iii* 0)
  (definePiece 0 3 1 0)
  (definePiece 0 1 0 3)
  (definePiece 0 0 3 1)
  (definePiece 0 1 3 0)
  (definePiece 0 3 0 1)
  (definePiece 0 0 1 3)

  (definePiece 1 2 0 0)
  (definePiece 1 0 2 0)
  (definePiece 1 0 0 2)

  (definePiece 2 1 1 0)
  (definePiece 2 1 0 1)
  (definePiece 2 0 1 1)

  (definePiece 3 1 1 1)

  (u16vector-set! *piececount* 0 13)
  (u16vector-set! *piececount* 1 3)
  (u16vector-set! *piececount* 2 1)
  (u16vector-set! *piececount* 3 1)
  (let ((m (fx+ (fx* *d* (fx+ *d* 1)) 1))
        (n 0))
    (cond
     ((fit 0 m) (set! n (place 0 m)))
     (else (newline) (display "Error.")))
    (if (trial n)
        *kount*
        #f)))

(define (run-benchmark)
  (let* ((count (read))
         (input1 (read))
         (output (read))
         (s2 (number->string count))
         (s1 input1)
         (name "puzzle"))
    (run-r7rs-benchmark
     (string-append name ":" s2)
     count
     (lambda () (start (hide count input1)))
     (lambda (result) (equal? result output)))))

(for-each (lambda (i) (vector-set! *p* i (make-vector (+ *size* 1))))
          (my-iota (+ typemax 1)))
